// --- GLOSSARY, GAME STATE, AND STATS ---
let glossary = [];
function loadGlossary() {
  try {
    const g = JSON.parse(localStorage.getItem("hkrpgquiz_glossary")||"[]");
    if(Array.isArray(g)) glossary = g;
  } catch(e){glossary=[];}
}
function saveGlossary() {
  // Check local storage size to prevent overflow (Technical Improvement)
  try {
    let data = JSON.stringify(glossary);
    let size = new Blob([data]).size;
    if (size > 5000000) { // Rough limit of 5MB (varies by browser)
      alert("Glossary data is too large. Consider resetting to free up space.");
      return false;
    }
    localStorage.setItem("hkrpgquiz_glossary", data);
    return true;
  } catch (e) {
    console.error("Storage error:", e);
    alert("Error saving glossary. Storage may be full.");
    return false;
  }
}
loadGlossary();
let state = {}, usedQuestions = [], currQuestion = null, bossQuestionPool = [], hintUsed = false;
let randomEventHappened = false, inRandomEvent = false, randomEventQ=0, randomEventCorrect=0, itemsGivenThisGame=[];
let correctStreak = 0; // For dynamic difficulty scaling (Gameplay Enhancement)
let gameStats = { highScore: 0, totalCorrect: 0, totalGames: 0, totalHints: 0, fastestGame: Infinity, startTime: 0 };
let achievements = [
  {name: "Perfect Streak", desc: "Answer 10 questions without a mistake", condition: "correctStreak >= 10", achieved: false},
  {name: "Item Collector", desc: "Collect all unique items", condition: "itemsGivenThisGame.length === itemList.length", achieved: false},
  {name: "No Hints Needed", desc: "Answer 10 questions without using hints", condition: "totalCorrectWithoutHint >= 10", achieved: false, tracker: 0},
  {name: "Speed Demon", desc: "Finish a game in under 5 minutes", condition: "fastestGame < 300000", achieved: false},
  {name: "Boss Slayer", desc: "Defeat the final boss", condition: "state.npcIndex >= npcs.length", achieved: false}
];

function loadStats() {
  try {
    const stats = JSON.parse(localStorage.getItem("hkrpgquiz_stats") || "{}");
    if (stats && typeof stats === 'object') {
      gameStats.highScore = stats.highScore || 0;
      gameStats.totalCorrect = stats.totalCorrect || 0;
      gameStats.totalGames = stats.totalGames || 0;
      gameStats.totalHints = stats.totalHints || 0;
      gameStats.fastestGame = stats.fastestGame || Infinity;
    }
    const savedAchievements = JSON.parse(localStorage.getItem("hkrpgquiz_achievements") || "[]");
    if (Array.isArray(savedAchievements) && savedAchievements.length === achievements.length) {
      achievements.forEach((ach, i) => {
        ach.achieved = savedAchievements[i].achieved || false;
        if (ach.tracker !== undefined) ach.tracker = savedAchievements[i].tracker || 0;
      });
    }
  } catch (e) {
    console.error("Error loading stats:", e);
  }
}
function saveStats() {
  localStorage.setItem("hkrpgquiz_stats", JSON.stringify(gameStats));
  localStorage.setItem("hkrpgquiz_achievements", JSON.stringify(achievements));
}
function updateAchievements() {
  achievements.forEach(ach => {
    if (!ach.achieved) {
      if (ach.condition === "correctStreak >= 10" && correctStreak >= 10) {
        ach.achieved = true;
        logMsg(`<span style="color:#FFD700">Achievement Unlocked: ${ach.name}!</span>`);
      } else if (ach.condition === "itemsGivenThisGame.length === itemList.length" && itemsGivenThisGame.length === itemList.length) {
        ach.achieved = true;
        logMsg(`<span style="color:#FFD700">Achievement Unlocked: ${ach.name}!</span>`);
      } else if (ach.condition === "totalCorrectWithoutHint >= 10" && ach.tracker >= 10) {
        ach.achieved = true;
        logMsg(`<span style="color:#FFD700">Achievement Unlocked: ${ach.name}!</span>`);
      } else if (ach.condition === "fastestGame < 300000" && gameStats.fastestGame < 300000) {
        ach.achieved = true;
        logMsg(`<span style="color:#FFD700">Achievement Unlocked: ${ach.name}!</span>`);
      } else if (ach.condition === "state.npcIndex >= npcs.length" && state.npcIndex >= npcs.length) {
        ach.achieved = true;
        logMsg(`<span style="color:#FFD700">Achievement Unlocked: ${ach.name}!</span>`);
      }
    }
  });
  saveStats();
}
loadStats();

// --- SAVE/RESUME ---
function saveGame() {
  localStorage.setItem("hkrpgquiz_save", JSON.stringify({
    state, usedQuestions, currQuestion, bossQuestionPool, hintUsed,
    randomEventHappened, inRandomEvent, randomEventQ, randomEventCorrect, itemsGivenThisGame, correctStreak
  }));
  document.getElementById('resume-btn').style.display = '';
  setTimeout(()=>{document.getElementById('resume-btn').style.display = '';},50);
}
function loadGame() {
  let d = JSON.parse(localStorage.getItem("hkrpgquiz_save"));
  if(!d) return false;
  state=d.state; usedQuestions=d.usedQuestions; currQuestion=d.currQuestion;
  bossQuestionPool=d.bossQuestionPool; hintUsed=d.hintUsed;
  randomEventHappened=d.randomEventHappened; inRandomEvent=d.inRandomEvent;
  randomEventQ=d.randomEventQ; randomEventCorrect=d.randomEventCorrect;
  itemsGivenThisGame=d.itemsGivenThisGame; correctStreak=d.correctStreak || 0;
  document.getElementById('menu').style.display = 'none';
  document.getElementById('game').style.display = '';
  document.getElementById('gameover').style.display = 'none';
  updateStory(); updateInventoryPanel(); updateStats();
  nextNpc(true);
  return true;
}
function clearSave() {
  localStorage.removeItem("hkrpgquiz_save");
  document.getElementById('resume-btn').style.display = 'none';
}

// --- UI UPDATES ---
function updateStats() {
  let playerHp = Math.max(0, state.player.hp);
  let npc = state.npcs[state.npcIndex];
  let npcHp = Math.max(0, npc.hp);
  document.getElementById('player-hp').style.width = (playerHp/state.player.maxHp*100) + "%";
  document.getElementById('npc-hp').style.width = (npcHp/npc.hp*100) + "%";
  document.getElementById('player-hp-text').textContent = `HP: ${playerHp}`;
  document.getElementById('npc-hp-text').textContent = `HP: ${npcHp}`;
  document.getElementById('npc-name').textContent = npc.name;
  document.getElementById('npc-img').textContent = npc.img || "ðŸ˜ˆ";
  document.getElementById('score').textContent = state.score;
  updateProgressBar();
  saveGame();
}
function logMsg(msg) {
  state.log.push(msg);
  if (state.log.length > 7) state.log.shift();
  document.getElementById('log').innerHTML = state.log.join('<br>');
}
function updateStory() {
  let idx = Math.min(state.npcIndex, storyline.length-1);
  document.getElementById('story').innerHTML = storyline[idx];
}
function updateInventoryPanel() {
  let div = document.getElementById('inventory');
  div.innerHTML = '';
  if (state.inventory.length === 0) {
    div.innerHTML = '<span class="inventory-empty">No items yet!</span>'; // Bug Fix: Empty Inventory Display
  } else {
    state.inventory.forEach((i,idx)=>{
      let btn = document.createElement('button');
      btn.className="inv-btn";
      btn.innerHTML = `${i.emoji} ${i.name}`;
      btn.title = i.desc;
      // Check cooldown for item usage strategy (Gameplay Enhancement)
      let currentTurn = state.turnCount || 0;
      if (i.cooldown > 0 && i.lastUsed >= 0 && (currentTurn - i.lastUsed) < i.cooldown) {
        btn.disabled = true;
        btn.title = `${i.desc} (Cooldown: ${i.cooldown - (currentTurn - i.lastUsed)} turns)`;
      } else if (state.itemsUsedThisBattle >= 1) { // Limit to 1 item per battle
        btn.disabled = true;
        btn.title = `${i.desc} (Limit: 1 item per battle)`;
      } else {
        btn.onclick = ()=>{
          i.effect(state);
          i.lastUsed = currentTurn;
          state.itemsUsedThisBattle++;
          state.inventory.splice(idx,1);
          updateInventoryPanel();
          updateStats();
          saveGame();
        };
      }
      div.appendChild(btn);
    });
  }
}
function updateProgressBar() {
  let total = npcs.length;
  let done = state.npcIndex;
  let progressBar = document.getElementById("progress-bar");
  progressBar.style.width = `${(done/total*100).toFixed(1)}%`;
  progressBar.title = done < total ? `Next: ${npcs[done].name}` : "Final Boss Defeated!"; // UI/UX Improvement: Tooltip for next NPC
  // Add level indicator (UI/UX Improvement: Progress Visualization)
  let levelText = `Level ${done+1}/${total}`;
  let scorePanel = document.getElementById('score-panel');
  scorePanel.innerHTML = `Score: <span id="score">${state.score}</span> | ${levelText}`;
}
