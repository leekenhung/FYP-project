// --- NPC AND QUESTION LOGIC ---
function nextNpc(isResume) {
  let npc = state.npcs[state.npcIndex];
  // Dynamic difficulty scaling based on correct streak (Gameplay Enhancement: Difficulty Scaling)
  let hpIncrease = Math.floor(correctStreak / 3) * 5; // Increase HP by 5 for every 3 correct answers
  let attackIncrease = Math.floor(correctStreak / 5) * 2; // Increase attack by 2 for every 5 correct answers
  npc.hp = npc.baseHp + hpIncrease;
  npc.attack = npc.baseAttack + attackIncrease;
  logMsg(`<span style="color:#FFD700">A wild <b>${npc.name}</b> appears!</span>`);
  if(npc.cat==="Boss") playSound("boss");
  updateStats();
  updateStory();
  state.itemsUsedThisBattle = 0; // Reset item usage limit per battle (Gameplay Enhancement: Item Usage Strategy)
  if(isResume && currQuestion) showQuestion(currQuestion); else nextQuestion();
}
function getQuestionsForCat(cat) {
  let pool;
  if(cat==="Loanwords from Cantonese") pool = questions.filter(q=>q.cat==="Loanwords from Cantonese" && !usedQuestions.includes(q.term));
  else if(cat==="Localized English Phrases & Expressions") pool = questions.filter(q=>q.cat==="Localized English Phrases & Expressions" && !usedQuestions.includes(q.term));
  else if(cat==="Unique Hong Kong Concepts in English") pool = questions.filter(q=>q.cat==="Unique Hong Kong Concepts in English" && !usedQuestions.includes(q.term));
  else if(cat==="Code-Mixing") pool = questions.filter(q=>q.cat==="Code-Mixing" && !usedQuestions.includes(q.term));
  else pool = [];
  if (pool.length < 1) pool = questions.filter(q=>!usedQuestions.includes(q.term)&&q.cat!=="Boss");
  return pool;
}
function maybeRandomEvent() {
  if(randomEventHappened||inRandomEvent||state.npcs[state.npcIndex].cat==="Boss") return false;
  if(Math.random()<0.3) {
    inRandomEvent = true; randomEventQ=0, randomEventCorrect=0;
    // Select a random event type (Gameplay Enhancement: More Interactive Random Events)
    let event = shuffle(randomEventTypes.slice())[0];
    document.getElementById("event").textContent = event.text;
    if (event.type === "quiz") {
      setTimeout(()=>randomEventQn(),400);
    } else if (event.type === "choice") {
      setTimeout(()=>randomEventChoice(event),400);
    } else if (event.type === "memory") {
      setTimeout(()=>randomEventMemory(event),400);
    }
    return true;
  }
  return false;
}
function randomEventQn() {
  let pool = questions.filter(q=>!usedQuestions.includes(q.term)&&q.cat!=="Boss");
  shuffle(pool);
  let q = pool[0];
  currQuestion = q;
  let answers = q.options.slice();
  shuffle(answers);
  document.getElementById('question').innerHTML = `Lucky Question ${randomEventQ+1}/2:<br><br><em>${q.desc}</em>`;
  let ansDiv = document.getElementById('answers');
  ansDiv.innerHTML = '';
  answers.forEach(ans=>{
    let btn = document.createElement('button');
    btn.textContent = ans;
    btn.onclick = ()=>randomEventAnswer(ans===q.term, ans, q);
    btn.setAttribute('tabindex', '0'); // Accessibility: keyboard navigation
    ansDiv.appendChild(btn);
  });
  setupKeyboardNavigation(); // Accessibility: Keyboard Navigation for answers
}
function randomEventAnswer(correct, answer, q) {
  Array.from(document.querySelectorAll('.answers button')).forEach(btn=>{
    btn.disabled=true;
    if (btn.textContent===q.term) btn.classList.add('correct');
    if (btn.textContent===answer && !correct) btn.classList.add('wrong');
  });
  setTimeout(()=>{
    if(correct) { playSound("hit"); randomEventCorrect++; }
    else playSound("wrong");
    usedQuestions.push(q.term);
    randomEventQ++;
    if(randomEventQ<2) {
      setTimeout(()=>randomEventQn(),350);
    } else {
      inRandomEvent = false; randomEventHappened = true;
      if(randomEventCorrect===2) {
        let remaining = itemList.filter(it=>!itemsGivenThisGame.includes(it.name)&&!state.inventory.some(i=>i.name===it.name));
        if(remaining.length) {
          let it = {...shuffle(remaining)[0]};
          state.inventory.push(it); itemsGivenThisGame.push(it.name);
          logMsg(`<span style="color:#FFD700">You won a new item: ${it.emoji} <b>${it.name}</b>!</span>`);
          playSound("item");
          updateInventoryPanel();
        } else {
          logMsg(`<span style="color:#FFD700">You answered both correctly! But you already have all items.</span>`);
        }
      } else {
        logMsg(`<span style="color:#FFD700">You didn't get both right. No prize this time!</span>`);
      }
      document.getElementById("event").textContent = "";
      setTimeout(()=>nextQuestion(),700);
    }
  },350);
}
function randomEventChoice(event) {
  document.getElementById('question').innerHTML = '';
  let ansDiv = document.getElementById('answers');
  ansDiv.innerHTML = '';
  let yesBtn = document.createElement('button');
  yesBtn.textContent = "Yes";
  yesBtn.onclick = () => {
    event.effect(state, "yes");
    document.getElementById("event").textContent = "";
    setTimeout(()=>nextQuestion(),700);
  };
  yesBtn.setAttribute('tabindex', '0');
  ansDiv.appendChild(yesBtn);
  let noBtn = document.createElement('button');
  noBtn.textContent = "No";
  noBtn.onclick = () => {
    event.effect(state, "no");
    document.getElementById("event").textContent = "";
    setTimeout(()=>nextQuestion(),700);
  };
  noBtn.setAttribute('tabindex', '0');
  ansDiv.appendChild(noBtn);
  setupKeyboardNavigation(); // Accessibility: Keyboard Navigation for choice buttons
}
function randomEventMemory(event) {
  let pool = questions.filter(q=>!usedQuestions.includes(q.term)&&q.cat!=="Boss");
  shuffle(pool);
  let q = pool[0];
  if (!q) {
    logMsg(`<span style="color:#FFD700">No terms left for memory challenge. Skipping...</span>`);
    document.getElementById("event").textContent = "";
    setTimeout(()=>nextQuestion(),700);
    return;
  }
  usedQuestions.push(q.term); // Mark as used even in memory challenge
  document.getElementById('question').innerHTML = `Match the term to its meaning:<br><br><b>${q.term}</b>`;
  let ansDiv = document.getElementById('answers');
  ansDiv.innerHTML = '';
  let meanings = [q.desc.split('.')[0]];
  let otherQs = questions.filter(qq=>qq.term!==q.term && !usedQuestions.includes(qq.term));
  shuffle(otherQs);
  for (let i=0; i<2 && i<otherQs.length; i++) {
    meanings.push(otherQs[i].desc.split('.')[0]);
  }
  shuffle(meanings).forEach(m=>{
    let btn = document.createElement('button');
    btn.textContent = m;
    btn.onclick = () => {
      let result = m === q.desc.split('.')[0] ? "success" : "fail";
      event.effect(state, result);
      document.getElementById("event").textContent = "";
      setTimeout(()=>nextQuestion(),700);
    };
    btn.setAttribute('tabindex', '0');
    ansDiv.appendChild(btn);
  });
  setupKeyboardNavigation(); // Accessibility: Keyboard Navigation for memory challenge buttons
}
function nextQuestion() {
  if(maybeRandomEvent()) return;
  state.skillEffects = state.skillEffects || {};
  hintUsed = false;
  document.getElementById("hint-btn").disabled = false;
  document.getElementById("event").textContent = "";
  let npc = state.npcs[state.npcIndex];
  if(npc.cat==="Boss") {
    if(!bossQuestionPool.length) bossQuestionPool = shuffle(questions.filter(q=>q.cat==="Boss"));
    let q;
    do { q = bossQuestionPool.pop(); } while(q && usedQuestions.includes(q.q) && bossQuestionPool.length>0);
    if(!q) { gameOver(true); return; }
    usedQuestions.push(q.q);
    showQuestion(q);
    return;
  }
  let pool = getQuestionsForCat(npc.cat).filter(q=>!usedQuestions.includes(q.term));
  shuffle(pool);
  let q = pool[0];
  if(!q) { gameOver(true); return; }
  usedQuestions.push(q.term);
  showQuestion(q);
  state.turnCount = (state.turnCount || 0) + 1; // Track turns for cooldowns
  state.itemsUsedThisBattle = 0; // Reset item usage per question/battle
}
function showQuestion(q) {
  currQuestion = q;
  let answers = (q.cat==="Boss") ? q.options.slice() : q.options.slice();
  shuffle(answers);
  document.getElementById('question').innerHTML =
    (q.cat==="Boss"
      ? `<b>Boss Question:</b><br>${q.q}`
      : `Which term matches this description?<br><br><em>${q.desc}</em>`);
  let ansDiv = document.getElementById('answers');
  ansDiv.innerHTML = '';
  answers.forEach(ans=>{
    let btn = document.createElement('button');
    btn.textContent = ans;
    btn.onclick = ()=>answer((q.cat==="Boss"?ans===q.correct:ans===q.term), ans, q.cat==="Boss");
    btn.setAttribute('tabindex', '0'); // Accessibility: keyboard navigation
    ansDiv.appendChild(btn);
  });
  // Accessibility: Add keyboard event listeners for answers (Accessibility Improvement)
  setupKeyboardNavigation();
}
function setupKeyboardNavigation() {
  Array.from(document.querySelectorAll('.answers button')).forEach((btn, index) => {
    btn.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        this.click();
      }
    });
  });
}
function answer(correct, answer, boss) {
  let npc = state.npcs[state.npcIndex];
  let resultMsg = '';
  let attack = state.player.attack;
  if(state.skillEffects.doubleAttack) { attack *= 2; state.skillEffects.doubleAttack = 0; resultMsg += "<span style='color:#FFD700'>Double Damage!</span><br>"; }
  let npcAttack = npc.attack;
  if(state.skillEffects.block){
    npcAttack = 0;
    state.skillEffects.block--;
    resultMsg += `<span style="color:#FFD7B5">Umbrella: Attack blocked!</span><br>`;
  }
  else if(state.skillEffects.skipEnemyAttack && !correct){
    npcAttack = 0;
    state.skillEffects.skipEnemyAttack = 0;
    resultMsg += `<span style="color:#FFD7B5">Egg Tart/Wet Towel: Enemy attack skipped!</span><br>`;
  }
  if(state.skillEffects.noDamage && !correct) {
    npcAttack = 0;
    state.skillEffects.noDamage = 0;
    resultMsg += `<span style="color:#FFD7B5">Egg Puff: No damage for this mistake!</span><br>`;
  }
  Array.from(document.querySelectorAll('.answers button')).forEach(btn=>{
    btn.disabled=true;
    if(boss){
      if(btn.textContent===currQuestion.correct) btn.classList.add('correct');
      if(btn.textContent===answer && !correct) btn.classList.add('wrong');
    } else {
      if (btn.textContent===currQuestion.term) btn.classList.add('correct');
      if (btn.textContent===answer && !correct) btn.classList.add('wrong');
    }
  });
  setTimeout(()=>{
    if (correct) {
      playSound("hit");
      state.score+=20;
      // Scoring multiplier for consecutive correct answers (Gameplay Enhancement: Difficulty Scaling)
      let multiplier = Math.floor(correctStreak / 5) * 5 + 20; // Bonus points for every 5 correct answers
      state.score += multiplier;
      npc.hp -= attack;
      correctStreak++; // Increment streak for difficulty scaling
      gameStats.totalCorrect++; // Track for stats
      if (!hintUsed) {
        achievements.find(a => a.name === "No Hints Needed").tracker++;
      }
      resultMsg += `<span style="color:#38ef7d">Correct! You hit for ${attack} damage. (+${20 + multiplier} pts)</span>`;
      // Add to glossary (no repeats) (Content and Cultural Depth)
      if(boss){
        if(!glossary.some(g=>g.term===currQuestion.correct))
          glossary.push({
            term: currQuestion.correct,
            pron: "",
            desc: currQuestion.q
          });
      } else {
        if(!glossary.some(g=>g.term===currQuestion.term))
          glossary.push({
            term: currQuestion.term,
            pron: currQuestion.pron||"",
            desc: currQuestion.desc
          });
      }
      saveGlossary();
      // Show cultural note if available (Content and Cultural Depth)
      if (currQuestion.culturalNote) {
        let noteDiv = document.getElementById('cultural-note');
        noteDiv.textContent = currQuestion.culturalNote;
        noteDiv.style.display = 'block';
        setTimeout(() => {
          noteDiv.style.display = 'none';
        }, 3000); // Hide after 3 seconds
      }
      if(state.skillEffects.extraTurn) {
        state.skillEffects.extraTurn=0;
        updateStats();
        logMsg(resultMsg + "<br><span style='color:#FFD700'>Octopus Card: You get another question!</span>");
        setTimeout(()=>nextQuestion(), 700);
        return;
      }
    } else {
      playSound("wrong");
      state.player.hp -= npcAttack;
      correctStreak = 0; // Reset streak on wrong answer
      achievements.find(a => a.name === "No Hints Needed").tracker = 0; // Reset no-hint streak
      resultMsg += `<span style="color:#f85032">Wrong! Enemy hits you for ${npcAttack} damage.</span>`;
    }
    updateAchievements(); // Check for achievement unlocks (Replayability and Engagement)
    updateStats();
    logMsg(resultMsg);
    setTimeout(()=>{ checkBattle(); }, 900);
  }, 350);
  // Visual feedback: Shake NPC image on hit (UI/UX Improvement)
  let npcImg = document.getElementById('npc-img');
  if (correct) {
    npcImg.classList.add('enemy-hit');
    setTimeout(() => npcImg.classList.remove('enemy-hit'), 200);
  }
}
function checkBattle() {
  let npc = state.npcs[state.npcIndex];
  if (npc.hp <= 0) {
    if (npc.boss) {
      localStorage.setItem("hkrpgquiz_game_completed", "true"); // Flag for New Game+ mode (Replayability and Engagement)
      return gameOver(true);
    }
    playSound("victory");
    logMsg(`<span style="color:#FFD700">You defeated ${npc.name}!</span>`);
    state.npcIndex++;
    if (state.npcIndex >= state.npcs.length) return gameOver(true);
    setTimeout(()=>nextNpc(), 700);
  } else if (state.player.hp <= 0) {
    gameOver(false);
  } else {
    setTimeout(()=>nextQuestion(), 400);
  }
}
function gameOver(won) {
  // Update fastest game time if won (Replayability and Engagement: Leaderboards or Stats)
  if (won) {
    let endTime = Date.now();
    let gameTime = endTime - gameStats.startTime;
    if (gameTime < gameStats.fastestGame) {
      gameStats.fastestGame = gameTime;
    }
    updateAchievements();
  }
  // Update high score
  if (state.score > gameStats.highScore) {
    gameStats.highScore = state.score;
  }
  saveStats();
  clearSave();
  document.getElementById('game').style.display = 'none';
  document.getElementById('gameover').style.display = '';
  if (won) {
    playSound("victory");
    document.getElementById('gameover-title').innerHTML = "Victory!";
    document.getElementById('gameover-msg').innerHTML = `${storyline[storyline.length-1]}<br><br>
    <b>Final Score: ${state.score}</b>`;
  } else {
    playSound("defeat");
    document.getElementById('gameover-title').innerHTML = "Defeated!";
    document.getElementById('gameover-msg').innerHTML = `You were defeated. Try again and add oil!<br>
    <b>Score: ${state.score}</b>`;
  }
}
